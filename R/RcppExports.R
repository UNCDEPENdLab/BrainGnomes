# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Zero-Phase IIR Filtering via Forward and Reverse Filtering
#'
#' Applies an IIR filter to a 1D numeric signal using forward and backward passes
#' to eliminate phase distortions, similar to `scipy.signal.filtfilt`.
#' This function implements a pure C++ version using the Direct Form II Transposed structure,
#' including optional initial condition handling via steady-state initialization.
#'
#' @name filtfilt_cpp
#' @param x A numeric vector representing the input time series.
#' @param b A numeric vector of numerator (feedforward) filter coefficients.
#' @param a A numeric vector of denominator (feedback) filter coefficients. Must have `a[0] == 1.0`.
#' @param padlen Number of samples to extend on each edge for padding. If `-1` (default), uses `3 * max(length(a), length(b))`.
#' @param padtype Type of padding at the signal boundaries. One of `"constant"` (default), `"odd"`, `"even"`, or `"zero"`.
#' @param use_zi Logical. If `TRUE` (default), use steady-state initial conditions to minimize transients.
#'
#' @return A numeric vector of the same length as `x`, containing the filtered signal.
#'
#' @details
#' The function applies the IIR filter in the forward direction, reverses the result,
#' and applies the filter again, then reverses the final output. This approach
#' removes phase delay. Padding is used to minimize edge artifacts, and the filter
#' state is optionally initialized with values derived from the steady-state
#' step response of the filter (`lfilter_zi_arma()`).
#'
#' @references
#' - Scipy Signal Documentation: \url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html}
#' - Gustafsson, F. (1996). Determining the initial states in forward-backward filtering. IEEE Transactions on Signal Processing.
#'
#' @seealso \code{\link{lfilter}}, \code{\link{lfilter_zi_arma}}
#'
#' @export
NULL

filtfilt_cpp <- function(x, b, a, padlen = -1L, padtype = "constant", use_zi = TRUE) {
    .Call(`_BrainGnomes_filtfilt_cpp`, x, b, a, padlen, padtype, use_zi)
}

#' Apply Butterworth Filter to 4D NIfTI Image
#'
#' This function applies a temporal Butterworth filter to each voxel time series
#' in a 4D NIfTI image using forward-backward filtering.
#'
#' @name butterworth_filter_cpp
#' @param infile Character string. Path to the input 4D NIfTI file.
#' @param b Numeric vector. Numerator filter coefficients.
#' @param a Numeric vector. Denominator filter coefficients.
#' @param outfile Character string. Optional path to save the filtered image.
#' @param internal Logical. Whether to return an internal RNifti image object (default = false).
#' @param padtype String. Padding type: "even", "odd", "constant", or "zero" (default = "even").
#' @param use_zi Logical. Whether to use steady-state initial conditions (default = true).
#'
#' @return A 4D filtered NIfTI image as a niftiImage or internalImage object.
#'
#' @keywords internal
butterworth_filter_cpp <- function(infile, b, a, outfile = "", internal = FALSE, padtype = "even", padlen = -1L, use_zi = TRUE) {
    .Call(`_BrainGnomes_butterworth_filter_cpp`, infile, b, a, outfile, internal, padtype, padlen, use_zi)
}

#' Apply Confound Regression to 4D fMRI Data Using Voxelwise Linear Models
#'
#' This function performs voxelwise confound regression by fitting a linear model to a subset of timepoints
#' (e.g., uncensored volumes) for each voxel in a 4D NIfTI image. The fitted model is then applied to all
#' timepoints to obtain predicted values, and the residuals are returned as a cleaned 4D image.
#'
#' This approach mirrors the strategy used in the XCP-D pipeline, where nuisance regressors are fit only
#' to valid (non-censored) timepoints to prevent bias, but the resulting model is applied to the full
#' dataset including censored timepoints (e.g., for continuity or interpolation).
#'
#' Constant columns in the design matrix are automatically removed. If an intercept column (all ones) is present,
#' it is preserved; otherwise, an intercept will be added if \code{add_intercept = TRUE}.
#'
#' @name lmfit_residuals_4d
#'
#' @param infile Path to a 4D NIfTI image file to denoise (e.g., functional data).
#' @param X A numeric matrix where rows correspond to timepoints and columns to nuisance regressors.
#'          Typically includes motion parameters, physiological noise, etc.
#' @param include_rows Logical vector indicating which timepoints to include in model fitting (e.g., uncensored).
#'          Must be the same length as the number of timepoints in the image and the number of rows in \code{X}.
#' @param add_intercept Logical; if \code{TRUE}, adds an intercept column to the design matrix unless one is already present.
#' @param outfile Optional path to write the output residuals image. If empty, no file is written.
#' @param internal Logical; if \code{TRUE}, returns an internal RNifti pointer. Otherwise returns an R array.
#' @param preserve_mean Logical; if \code{TRUE}, constant time series will be left unchanged (not demeaned or recentered).
#' @param set_mean Optional numeric value; if specified, all residual time series will be shifted to have this mean
#'        (default is 0). Cannot be used in combination with \code{preserve_mean = TRUE}.
#'
#' @return A residualized 4D NIfTI image, either as an in-memory array or RNifti object (if \code{internal = TRUE}).
#' @export
#'
#' @examples
#' \dontrun{
#'   X <- cbind(1, motion_params, compcor)
#'   residual_img <- lmfit_residuals_4d(
#'     infile = "func.nii.gz",
#'     X = X,
#'     include_rows = !censor_vector,
#'     add_intercept = TRUE,
#'     outfile = "residual.nii.gz",
#'     set_mean = 1000
#'   )
#' }
#' 
#' @references
#' Ciric, R. et al. (2018). Mitigating head motion artifact in functional connectivity MRI. *Nature Protocols*.
#' https://xcp-d.readthedocs.io/en/latest/
#' https://dannyjameswilliams.co.uk/portfolios/sc2/rcpp/
NULL

lmfit_residuals_4d <- function(infile, X, include_rows, add_intercept = TRUE, outfile = "", internal = FALSE, preserve_mean = FALSE, set_mean = 0.0) {
    .Call(`_BrainGnomes_lmfit_residuals_4d`, infile, X, include_rows, add_intercept, outfile, internal, preserve_mean, set_mean)
}

#' Interpolate fMRI Time Series with Cubic Splines in a NIfTI File
#'
#' This function performs voxelwise natural cubic spline interpolation over the time
#' dimension of a 4D NIfTI image. Timepoints to interpolate are specified, and interpolation
#' is applied independently to each voxel's time series.
#'
#' The function reads the NIfTI image from disk, performs interpolation in memory,
#' and optionally writes the result back to a new NIfTI file.
#'
#' @name natural_spline_4d
#' @param infile Character string. Path to the input 4D NIfTI file (e.g., BOLD fMRI data).
#' @param t_interpolate Integer vector (1-based). Specifies the timepoints (TRs) to interpolate.
#'        Timepoints outside the valid range [1, T] are ignored with a warning.
#' @param edge_nn Logical. If \code{TRUE}, extrapolated values at the edges of the time series
#'        are filled in using nearest-neighbor extrapolation instead of cubic splines.
#' @param outfile Character string (optional). If provided, the interpolated image will
#'        be written to this path. If omitted, the result is returned but not saved.
#' @param internal Logical. If FALSE (the default), an array of class "niftiImage", containing
#'        the image pixel or voxel values, will be returned. If TRUE, the return value will be
#'        an object of class "internalImage", which contains only minimal metadata about the image.
#'        Either way, the return value has an attribute which points to a C data structure
#'        containing the full image. Cf. `RNifti::readNifti`
#'
#' @return A \code{niftiImage} object with the same dimensions and metadata as the input,
#'         with interpolated values inserted at the specified timepoints.
#'
#' @details The interpolation is voxelwise and assumes column-major order. If a voxel time series
#' has fewer than three valid (non-interpolated) timepoints, or is constant across time, it is skipped.
#' Linear extrapolation is used for timepoints outside the valid range if \code{edge_nn = FALSE}, matching
#' R's `splinefun` approach with natural splines. If \code{edge_nn = TRUE}, nearest-neighbor extrapolation
#' is used for interpolation timepoints at the beginning or end of the timeseries, potentially reducing
#' extreme values in extrapolation.
#'
#' This implementation uses RNiftiâ€™s C++ API (\code{NiftiImage}, \code{NiftiImageData}) for efficient
#' memory access and file handling, allowing the function to operate directly on NIfTI files.
#'
#' @examples
#' \dontrun{
#' out_img <- natural_spline_4d(
#'   infile = "bold.nii.gz",
#'   t_interpolate = 91:95,
#'   outfile = "bold_interpolated.nii.gz",
#'   edge_nn = TRUE
#' )
#' }
#' @import RNifti
#' @export
NULL

natural_spline_4d <- function(infile, t_interpolate, edge_nn = FALSE, outfile = "", internal = FALSE) {
    .Call(`_BrainGnomes_natural_spline_4d`, infile, t_interpolate, edge_nn, outfile, internal)
}

#' Cubic spline interpolation with natural spline and linear extrapolation
#' 
#' @name natural_spline_interp
#' @description Performs natural cubic spline interpolation for given input values.
#' This function takes known data points `(x, y)` and evaluates the cubic spline
#' interpolation at specified output points `xout`. It uses a natural spline
#' formulation with zero second derivatives at the endpoints.
#'
#' @param x A numeric vector of strictly increasing x-values (time or position).
#' @param y A numeric vector of y-values at each x (same length as x).
#' @param xout A numeric vector of points at which to interpolate.
#'
#' @return A numeric vector of interpolated y-values at each point in `xout`.
#'
#' @details The function performs cubic spline interpolation using a tridiagonal
#' system to solve for the spline coefficients. If `xout` values fall outside
#' the `x` range, the function uses linear extrapolation, mirror R's `splinefun`
#' with `method = "natural"`
#'
#' @examples
#'   x <- c(0, 1, 2, 3, 4)
#'   y <- c(0, 1, 0, 1, 0)
#'   xout <- seq(0, 4, by = 0.1)
#'   natural_spline_interp(x, y, xout)
#' @export
NULL

natural_spline_interp <- function(x, y, xout) {
    .Call(`_BrainGnomes_natural_spline_interp`, x, y, xout)
}

#' Remove Specified Timepoints from a 4D NIfTI Image
#'
#' This function removes specified timepoints (volumes) from a 4D NIfTI image and saves
#' the resulting image to a new file. Timepoints are specified using 1-based indexing,
#' consistent with R conventions.
#'
#' @name remove_nifti_volumes
#' @param infile Character string. Path to the input 4D NIfTI file.
#' @param remove_tpts Integer vector. Timepoints (1-based) to remove from the image.
#' @param outfile Character string. Path to save the output NIfTI file with selected volumes.
#'
#' @return None. The function writes a new NIfTI file to \code{outfile}.
#'
#' @details This function uses the \code{volumes} argument in RNifti to efficiently read
#' only the retained timepoints from disk. If all volumes are removed, an error is thrown.
#' The input image must be 4-dimensional (i.e., include a time dimension).
#'
#' @examples
#' \dontrun{
#' remove_nifti_volumes("input_bold.nii.gz", remove_tpts = c(1, 2, 100), outfile = "trimmed_bold.nii.gz")
#' }
#'
#' @export
NULL

remove_nifti_volumes <- function(infile, remove_tpts, outfile) {
    invisible(.Call(`_BrainGnomes_remove_nifti_volumes`, infile, remove_tpts, outfile))
}

