# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Zero-Phase IIR Filtering via Forward and Reverse Filtering
#'
#' Applies an IIR filter to a 1D numeric signal using forward and backward passes
#' to eliminate phase distortions, similar to `scipy.signal.filtfilt`.
#' This function implements a pure C++ version using the Direct Form II Transposed structure,
#' including optional initial condition handling via steady-state initialization.
#'
#' @name filtfilt_cpp
#' @param x A numeric vector representing the input time series.
#' @param b A numeric vector of numerator (feedforward) filter coefficients.
#' @param a A numeric vector of denominator (feedback) filter coefficients. Must have `a[0] == 1.0`.
#' @param padlen Number of samples to extend on each edge for padding. If `-1` (default), uses `3 * max(length(a), length(b))`.
#' @param padtype Type of padding at the signal boundaries. One of `"constant"` (default), `"odd"`, `"even"`, or `"zero"`.
#' @param use_zi Logical. If `TRUE` (default), use steady-state initial conditions to minimize transients.
#'
#' @return A numeric vector of the same length as `x`, containing the filtered signal.
#'
#' @details
#' The function applies the IIR filter in the forward direction, reverses the result,
#' and applies the filter again, then reverses the final output. This approach
#' removes phase delay. Padding is used to minimize edge artifacts, and the filter
#' state is optionally initialized with values derived from the steady-state
#' step response of the filter (`lfilter_zi_arma()`).
#'
#' @references
#' - Scipy Signal Documentation: \url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html}
#' - Gustafsson, F. (1996). Determining the initial states in forward-backward filtering. IEEE Transactions on Signal Processing.
#'
#' @export
NULL

#' Apply Butterworth Filter to 4D NIfTI Image
#'
#' This function applies a temporal Butterworth filter to each voxel time series
#' in a 4D NIfTI image using forward-backward filtering.
#'
#' @name butterworth_filter_cpp
#' @param infile Character string. Path to the input 4D NIfTI file.
#' @param b Numeric vector. Numerator filter coefficients.
#' @param a Numeric vector. Denominator filter coefficients.
#' @param outfile Character string. Optional path to save the filtered image.
#' @param internal Logical. Whether to return an internal RNifti image object (default = false).
#' @param padtype String. Padding type: "even", "odd", "constant", or "zero" (default = "even").
#' @param use_zi Logical. Whether to use steady-state initial conditions (default = true).
#' @param demean Logical. Whether to demean the timeseries prior to filtering. Usually a good to remove 
NULL

filtfilt_cpp <- function(x, b, a, padlen = -1L, padtype = "constant", use_zi = TRUE) {
    .Call(`_BrainGnomes_filtfilt_cpp`, x, b, a, padlen, padtype, use_zi)
}

#'
#' @return A 4D filtered NIfTI image as a niftiImage or internalImage object.
#'
#' @keywords internal
butterworth_filter_cpp <- function(infile, b, a, outfile = "", internal = FALSE, padtype = "even", padlen = -1L, use_zi = TRUE, demean = TRUE) {
    .Call(`_BrainGnomes_butterworth_filter_cpp`, infile, b, a, outfile, internal, padtype, padlen, use_zi, demean)
}

#' Read a Line of Input from the User in Both Interactive and Non-Interactive Sessions
#'
#' Provides a safe and portable way to prompt the user for input from the terminal,
#' working seamlessly in both interactive R sessions and non-interactive `Rscript`
#' sessions (when connected to a TTY).
#'
#' In an interactive session (e.g., RStudio or R console), this function delegates
#' to base R's `readline()`. In non-interactive contexts where a TTY is available,
#' it switches the terminal to non-canonical mode and performs low-level character-by-character
#' input handling with support for echoing, backspace editing, and cancellation
#' via Escape or EOF. Ctrl+C will terminate the process as usual.
#'
#' @param prompt A character string to display as the input prompt.
#'
#' @return A character string with the user's input, or `NULL` (`R_NilValue`) if input is cancelled
#' via Escape (`ESC`, ASCII 27) or EOF (`Ctrl+D` or equivalent).
#'
#' @details
#' - Supports visible typing and live editing with backspace.
#' - Returns early with `NULL` if the user presses Escape or EOF.
#' - Uses raw terminal input in non-interactive mode; requires that stdin is a TTY.
#' - Does **not** intercept `Ctrl+C`; this will terminate the process as normal.
#'
#' @examples
#' \dontrun{
#'   # In Rscript or R console
#'   input <- readline_safe("Enter your name: ")
#'   if (!is.null(input)) cat("Hello,", input, "!\n")
#' }
#'
#' @export
getline <- function(prompt) {
    .Call(`_BrainGnomes_getline`, prompt)
}

#' Compute Quantiles from a 3D or 4D NIfTI Image
#'
#' Computes one or more quantiles from a 3D or 4D NIfTI image. Optionally applies a 3D brain mask
#' and/or excludes zero-valued voxels. For 4D images, the function pools over all timepoints.
#'
#' @name image_quantile
#' @param in_file Path to the input 3D or 4D NIfTI image (.nii or .nii.gz).
#' @param brain_mask Optional path to a 3D NIfTI image used as a brain mask. Voxels with values > 0.001 are retained.
#'                  The mask must have the same spatial dimensions as the input image. If \code{R_NilValue}, no mask is used.
#' @param quantiles A numeric vector of probabilities in `[0, 1]` specifying which quantiles to compute (e.g., 0.5 for the median).
#' @param exclude_zero If \code{true}, zero-valued voxels in the image will be excluded from the quantile calculation.
#'
#' @return A named numeric vector of quantiles. Names are formatted as percentage strings (e.g., "50.00%").
#'
#' @details
#' - For 4D images, the mask (if used) is applied identically to all volumes.
#' - Quantile calculation uses partial sorting for performance (via \code{std::nth_element}).
#' - Throws an error if no voxels are valid after masking or zero exclusion.
#'
#' @examples
#' \dontrun{
#' # Compute the median
#' image_quantile("bold.nii.gz", 0.5)
#'
#' # With masking and zero exclusion
#' image_quantile("bold.nii.gz", "mask.nii.gz", c(0.25, 0.5, 0.75), exclude_zero=TRUE)
#' }
#'
#' @export
NULL

image_quantile <- function(in_file, brain_mask = NULL, quantiles = as.numeric( c(0.5)), exclude_zero = FALSE) {
    .Call(`_BrainGnomes_image_quantile`, in_file, brain_mask, quantiles, exclude_zero)
}

#' Apply Confound Regression to 4D fMRI Data Using Voxelwise Linear Models
#'
#' This function performs voxelwise confound regression by fitting a linear model to a subset of timepoints
#' (e.g., uncensored volumes) for each voxel in a 4D NIfTI image. The fitted model is then applied to all
#' timepoints to obtain predicted values, and the residuals are returned as a cleaned 4D image.
#'
#' This approach mirrors the strategy used in the XCP-D pipeline, where nuisance regressors are fit only
#' to valid (non-censored) timepoints to prevent bias, but the resulting model is applied to the full
#' dataset including censored timepoints (e.g., for continuity or interpolation).
#'
#' Constant columns in the design matrix are automatically removed. If an intercept column (all ones) is present,
#' it is preserved; otherwise, an intercept will be added if \code{add_intercept = TRUE}.
#'
#' @name lmfit_residuals_4d
#'
#' @param infile Path to a 4D NIfTI image file to denoise (e.g., functional data).
#' @param X A numeric matrix where rows correspond to timepoints and columns to nuisance regressors.
#'          Typically includes motion parameters, physiological noise, etc.
#' @param include_rows Logical vector indicating which timepoints to include in model fitting (e.g., uncensored).
#'          Must be the same length as the number of timepoints in the image and the number of rows in \code{X}.
#' @param add_intercept Logical; if \code{TRUE}, adds an intercept column to the design matrix unless one is already present.
#' @param outfile Optional path to write the output residuals image. If empty, no file is written.
#' @param internal Logical; if \code{TRUE}, returns an internal RNifti pointer. Otherwise returns an R array.
#' @param preserve_mean Logical; if \code{TRUE}, constant time series will be left unchanged (not demeaned or recentered).
#' @param set_mean Optional numeric value; if specified, all residual time series will be shifted to have this mean
#'        (default is 0). Cannot be used in combination with \code{preserve_mean = TRUE}.
#'
#' @return A residualized 4D NIfTI image, either as an in-memory array or RNifti object (if \code{internal = TRUE}).
#' @export
#'
#' @examples
#' \dontrun{
#'   X <- cbind(1, motion_params, compcor)
#'   residual_img <- lmfit_residuals_4d(
#'     infile = "func.nii.gz",
#'     X = X,
#'     include_rows = !censor_vector,
#'     add_intercept = TRUE,
#'     outfile = "residual.nii.gz",
#'     set_mean = 1000
#'   )
#' }
#' 
#' @references
#' Ciric, R. et al. (2018). Mitigating head motion artifact in functional connectivity MRI. *Nature Protocols*.
#' https://xcp-d.readthedocs.io/en/latest/
#' https://dannyjameswilliams.co.uk/portfolios/sc2/rcpp/
NULL

lmfit_residuals_4d <- function(infile, X, include_rows, add_intercept = TRUE, outfile = "", internal = FALSE, preserve_mean = FALSE, set_mean = 0.0) {
    .Call(`_BrainGnomes_lmfit_residuals_4d`, infile, X, include_rows, add_intercept, outfile, internal, preserve_mean, set_mean)
}

#' Portable Menu Prompt for Interactive or TTY Sessions
#'
#' This function mimics the behavior of base R's `menu()` function. In interactive
#' sessions (e.g., R console or RStudio), it calls `utils::menu()` directly. In
#' non-interactive but TTY-capable sessions (e.g., an `Rscript` run in a terminal),
#' it displays a numbered list of choices and uses standard input to read the user's selection.
#'
#' The menu allows selection of an option by entering the corresponding number,
#' with `0` used to cancel the selection (consistent with `menu()` behavior).
#'
#' @param choices A character vector of menu options to present to the user.
#' @param title Optional character string to display as the menu title.
#' @return An integer corresponding to the selected menu item (1-based index), or 0 if cancelled.
#'
#' @details
#' - If `menu_safe()` is called in an interactive R session, it defers to `utils::menu()`.
#' - In a non-interactive terminal (TTY), it prints the options and reads user input via `std::getline()`.
#' - If standard input is not connected to a terminal (e.g., piped input), the function returns 0 and prints a warning.
#'
#' @examples
#' \dontrun{
#' # Interactive R session
#' choice <- menu_safe(c("Apple", "Banana", "Cherry"), "Choose a fruit:")
#' if (choice == 0) cat("You cancelled the selection.\n")
#' else cat("You selected:", choice, "\n")
#'
#' # From a terminal via Rscript
#' # Rscript -e 'Rcpp::sourceCpp("menu_safe.cpp"); menu_safe(c("Yes", "No"))'
#' }
#'
#' @importFrom utils menu
#' @keywords internal
menu_safe <- function(choices, title = NULL) {
    .Call(`_BrainGnomes_menu_safe`, choices, title)
}

#' Interpolate fMRI Time Series with Cubic Splines in a NIfTI File
#'
#' This function performs voxelwise natural cubic spline interpolation over the time
#' dimension of a 4D NIfTI image. Timepoints to interpolate are specified, and interpolation
#' is applied independently to each voxel's time series.
#'
#' The function reads the NIfTI image from disk, performs interpolation in memory,
#' and optionally writes the result back to a new NIfTI file.
#'
#' @name natural_spline_4d
#' @param infile Character string. Path to the input 4D NIfTI file (e.g., BOLD fMRI data).
#' @param t_interpolate Integer vector (1-based). Specifies the timepoints (TRs) to interpolate.
#'        Timepoints outside the valid range `[1, T]` are ignored with a warning.
#' @param edge_nn Logical. If \code{TRUE}, extrapolated values at the edges of the time series
#'        are filled in using nearest-neighbor extrapolation instead of cubic splines.
#' @param outfile Character string (optional). If provided, the interpolated image will
#'        be written to this path. If omitted, the result is returned but not saved.
#' @param internal Logical. If FALSE (the default), an array of class "niftiImage", containing
#'        the image pixel or voxel values, will be returned. If TRUE, the return value will be
#'        an object of class "internalImage", which contains only minimal metadata about the image.
#'        Either way, the return value has an attribute which points to a C data structure
#'        containing the full image. Cf. `RNifti::readNifti`
#'
#' @return A \code{niftiImage} object with the same dimensions and metadata as the input,
#'         with interpolated values inserted at the specified timepoints.
#'
#' @details The interpolation is voxelwise and assumes column-major order. If a voxel time series
#' has fewer than three valid (non-interpolated) timepoints, or is constant across time, it is skipped.
#' Linear extrapolation is used for timepoints outside the valid range if \code{edge_nn = FALSE}, matching
#' R's `splinefun` approach with natural splines. If \code{edge_nn = TRUE}, nearest-neighbor extrapolation
#' is used for interpolation timepoints at the beginning or end of the timeseries, potentially reducing
#' extreme values in extrapolation.
#'
#' This implementation uses RNifti's C++ API (\code{NiftiImage}, \code{NiftiImageData}) for efficient
#' memory access and file handling, allowing the function to operate directly on NIfTI files.
#'
#' @examples
#' \dontrun{
#' out_img <- natural_spline_4d(
#'   infile = "bold.nii.gz",
#'   t_interpolate = 91:95,
#'   outfile = "bold_interpolated.nii.gz",
#'   edge_nn = TRUE
#' )
#' }
#' @import RNifti
#' @export
NULL

natural_spline_4d <- function(infile, t_interpolate, edge_nn = FALSE, outfile = "", internal = FALSE) {
    .Call(`_BrainGnomes_natural_spline_4d`, infile, t_interpolate, edge_nn, outfile, internal)
}

#' Cubic spline interpolation with natural spline and linear extrapolation
#' 
#' @name natural_spline_interp
#' @description Performs natural cubic spline interpolation for given input values.
#' This function takes known data points `(x, y)` and evaluates the cubic spline
#' interpolation at specified output points `xout`. It uses a natural spline
#' formulation with zero second derivatives at the endpoints.
#'
#' @param x A numeric vector of strictly increasing x-values (time or position).
#' @param y A numeric vector of y-values at each x (same length as x).
#' @param xout A numeric vector of points at which to interpolate.
#'
#' @return A numeric vector of interpolated y-values at each point in `xout`.
#'
#' @details The function performs cubic spline interpolation using a tridiagonal
#' system to solve for the spline coefficients. If `xout` values fall outside
#' the `x` range, the function uses linear extrapolation, mirror R's `splinefun`
#' with `method = "natural"`
#'
#' @examples
#'   x <- c(0, 1, 2, 3, 4)
#'   y <- c(0, 1, 0, 1, 0)
#'   xout <- seq(0, 4, by = 0.1)
#'   natural_spline_interp(x, y, xout)
#' @export
NULL

natural_spline_interp <- function(x, y, xout) {
    .Call(`_BrainGnomes_natural_spline_interp`, x, y, xout)
}

#' Remove Specified Timepoints from a 4D NIfTI Image
#'
#' This function removes specified timepoints (volumes) from a 4D NIfTI image and saves
#' the resulting image to a new file. Timepoints are specified using 1-based indexing,
#' consistent with R conventions.
#'
#' @name remove_nifti_volumes
#' @param infile Character string. Path to the input 4D NIfTI file.
#' @param remove_tpts Integer vector. Timepoints (1-based) to remove from the image.
#' @param outfile Character string. Path to save the output NIfTI file with selected volumes.
#'
#' @return None. The function writes a new NIfTI file to \code{outfile}.
#'
#' @details This function uses the \code{volumes} argument in RNifti to efficiently read
#' only the retained timepoints from disk. If all volumes are removed, an error is thrown.
#' The input image must be 4-dimensional (i.e., include a time dimension).
#'
#' @examples
#' \dontrun{
#' remove_nifti_volumes("input_bold.nii.gz", remove_tpts = c(1, 2, 100), 
#'   outfile = "trimmed_bold.nii.gz")
#' }
#'
#' @export
NULL

remove_nifti_volumes <- function(infile, remove_tpts, outfile) {
    invisible(.Call(`_BrainGnomes_remove_nifti_volumes`, infile, remove_tpts, outfile))
}

