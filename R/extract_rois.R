#' Extract ROI timeseries and connectivity matrices
#'
#' Given a postprocessed BOLD NIfTI file and one or more atlas images,
#' this function computes the mean timeseries within each ROI and
#' optionally computes ROI-to-ROI correlation matrices.
#'
#' Voxels labelled in the atlas but lying outside the brain are
#' automatically excluded by intersecting with a brain mask derived from
#' the input timeseries.
#'
#' @param bold_file Path to a 4D NIfTI file containing postprocessed BOLD data.
#' @param atlas_files Character vector of atlas NIfTI files with integer
#'   ROI labels.
#' @param out_dir Directory where output files should be written.
#' @param cor_method Correlation method(s) to use when computing functional
#'   connectivity. Supported options include "pearson", "spearman",
#'   "kendall", and "cor.shrink". Use "none" to skip correlation
#'   computation. Multiple methods may be supplied.
#' @param roi_reduce Method used to summarize voxel time series within each
#'   ROI. Options are "mean" (default), "median", "pca", or "huber".
#' @param brain_mask Optional brain mask NIfTI file. If \code{NULL}, a mask
#'   is generated by excluding voxels with zero variance across time.
#'
#' @return A named list. Each element corresponds to an atlas and contains
#'   paths to the written timeseries (\code{timeseries}) and correlation
#'   matrix (\code{correlation}, or \code{NULL} if not computed).
#' @export
extract_rois <- function(bold_file, atlas_files, out_dir,
                         cor_method = c("pearson", "spearman", "kendall",
                                        "cor.shrink", "none"),
                         roi_reduce = c("mean", "median", "pca", "huber"),
                         brain_mask = NULL) {
  checkmate::assert_file_exists(bold_file)
  checkmate::assert_character(atlas_files, any.missing = FALSE, min.len = 1)
  checkmate::assert_directory_exists(out_dir, access = "w")
  cor_method <- match.arg(cor_method, several.ok = TRUE)
  roi_reduce <- match.arg(roi_reduce)

  bold_img <- RNifti::readNifti(bold_file)
  dim_img <- dim(bold_img)
  if (length(dim_img) != 4L) stop("bold_file must be a 4D NIfTI image")
  n_time <- dim_img[4]
  mat <- matrix(bold_img, prod(dim_img[1:3]), n_time)

  # Determine brain mask
  if (is.null(brain_mask)) {
    brain_mask_vec <- apply(mat, 1, function(v) !all(v == 0) && stats::var(v) > 0)
  } else if (checkmate::test_file_exists(brain_mask)) {
    brain_mask_vec <- as.vector(RNifti::readNifti(brain_mask)) > 0
  } else {
    stop("brain_mask must be a valid NIfTI file or NULL")
  }

  bids_info <- as.list(extract_bids_info(bold_file))
  outputs <- list()

  for (atlas in atlas_files) {
    checkmate::assert_file_exists(atlas)
    atlas_img <- RNifti::readNifti(atlas)
    atlas_vec <- as.vector(atlas_img)
    roi_vals <- sort(unique(atlas_vec[atlas_vec > 0]))

    ts_mat <- sapply(roi_vals, function(lbl) {
      vox <- which(atlas_vec == lbl & brain_mask_vec)
      if (length(vox) < 5) {
        rep(NA_real_, n_time)
      } else {
        vals <- mat[vox, , drop = FALSE]
        bad <- apply(vals, 1, function(ts) any(is.na(ts)) || all(ts == 0) || stats::var(ts) == 0)
        if (sum(!bad) < 5) {
          rep(NA_real_, n_time)
        } else {
          roivox <- t(vals[!bad, , drop = FALSE]) # time x voxels
          if (roi_reduce == "pca") {
            pc <- stats::prcomp(roivox, scale. = TRUE)$x[, 1]
            mn <- rowMeans(roivox)
            if (stats::cor(pc, mn) < 0) pc <- -pc
            pc
          } else if (roi_reduce == "median") {
            apply(roivox, 1, median)
          } else if (roi_reduce == "huber") {
            apply(roivox, 1, function(x) MASS::huber(x)$mu)
          } else {
            rowMeans(roivox)
          }
        }
      }
    })

    ts_df <- as.data.frame(ts_mat)
    colnames(ts_df) <- paste0("roi", roi_vals)
    ts_df$time <- seq_len(n_time)
    ts_df <- ts_df[, c("time", paste0("roi", roi_vals))]

    atlas_name <- sub("\\.nii(\\.gz)?$", "", basename(atlas))
    desc <- paste0(atlas_name, if (!is.null(bids_info$description)) paste0("_", bids_info$description) else "")
    out_dir_atlas <- file.path(out_dir, atlas_name)
    if (!dir.exists(out_dir_atlas)) dir.create(out_dir_atlas, recursive = TRUE)

    ts_bids <- modifyList(bids_info, list(description = desc, suffix = "timeseries", ext = ".tsv"))
    ts_file <- file.path(out_dir_atlas, construct_bids_filename(ts_bids, full.names = FALSE))
    data.table::fwrite(ts_df, ts_file, sep = "\t")

    cor_files <- NULL
    if (!all(cor_method == "none")) {
      cor_files <- lapply(cor_method[cor_method != "none"], function(cmeth) {
        cmat <- if (cmeth == "cor.shrink") {
          corpcor::cor.shrink(ts_mat)
        } else {
          stats::cor(ts_mat, method = cmeth, use = "pairwise.complete.obs")
        }
        cor_bids <- modifyList(bids_info, list(description = paste0(desc, "_cor-", cmeth),
                                               suffix = "connectivity", ext = ".tsv"))
        cor_file <- file.path(out_dir_atlas, construct_bids_filename(cor_bids, full.names = FALSE))
        data.table::fwrite(as.data.frame(cmat), cor_file, sep = "\t")
        cor_file
      })
      names(cor_files) <- cor_method[cor_method != "none"]
    }

    outputs[[atlas_name]] <- list(timeseries = ts_file, correlation = cor_files)
  }

  return(outputs)
}
