<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>BrainGnomes Postprocessing Walkthrough • BrainGnomes</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="BrainGnomes Postprocessing Walkthrough">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">BrainGnomes</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.7-2</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/braingnomes_quickstart.html">BrainGnomes Quickstart</a></li>
    <li><a class="dropdown-item" href="../articles/building_containers.html">Building Singularity containers for BrainGnomes</a></li>
    <li><a class="dropdown-item" href="../articles/extract_rois.html">Extracting ROI Timeseries and Connectivity</a></li>
    <li><a class="dropdown-item" href="../articles/postprocessing.html">BrainGnomes Postprocessing Walkthrough</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/UNCDEPENdLab/BrainGnomes/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>BrainGnomes Postprocessing Walkthrough</h1>
                        <h4 data-toc-skip class="author">Michael
Hallquist</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/UNCDEPENdLab/BrainGnomes/blob/0.7-2/vignettes/postprocessing.Rmd" class="external-link"><code>vignettes/postprocessing.Rmd</code></a></small>
      <div class="d-none name"><code>postprocessing.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h2>
<p>This vignette focuses on the <strong>postprocessing</strong> features
of the <code>BrainGnomes</code> package. Postprocessing refers to the
optional steps that can be applied <em>after</em> fMRIPrep has generated
preprocessed BOLD files. These operations include masking, spatial
smoothing, ICA‑AROMA denoising, scrubbing, temporal filtering, intensity
normalisation and confound handling. Configuration of these steps occurs
via <code><a href="../reference/setup_project.html">setup_project()</a></code> when a project is first created or
later through <code><a href="../reference/edit_project.html">edit_project()</a></code>.</p>
<p>To get started, make sure you have created a project configuration
object (here, we will call it <code>scfg</code>) using
<code><a href="../reference/setup_project.html">setup_project()</a></code> or loaded one with
<code><a href="../reference/load_project.html">load_project()</a></code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://uncdependlab.github.io/BrainGnomes/">BrainGnomes</a></span><span class="op">)</span></span>
<span><span class="co"># scfg &lt;- setup_project()  # or load_project("/path/to/project")</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="enabling-postprocessing">Enabling Postprocessing<a class="anchor" aria-label="anchor" href="#enabling-postprocessing"></a>
</h2>
<p>During <code><a href="../reference/setup_project.html">setup_project()</a></code> you will be asked whether to
enable postprocessing for BOLD data. You can toggle this choice later
with <code>edit_project(scfg)</code>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">scfg</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/edit_project.html">edit_project</a></span><span class="op">(</span><span class="va">scfg</span><span class="op">)</span>  <span class="co"># choose "Postprocessing" from the menu</span></span></code></pre></div>
<p>Once enabled, each step described below can be configured
interactively.</p>
</div>
<div class="section level2">
<h2 id="postprocessing-streams">Postprocessing streams<a class="anchor" aria-label="anchor" href="#postprocessing-streams"></a>
</h2>
<p>Postprocessing supports multiple streams, allowing you to postprocess
data in multiple ways. For example, perhaps you’d like to compare
results for a 5mm versus 6mm spatial smoothing kernel.</p>
<p>Each stream also asks about which files should be entered into the
stream. For example, files with ‘rest’ in their name could be
postprocessed in one way and files with ‘nback’ could be processed a
different way.</p>
<p>The menu for setting up postprocessing streams looks like this:</p>
<pre><code>Current postprocessing streams:
  (none defined yet)

Modify postprocessing streams: 

1: Add a stream
2: Edit a stream
3: Delete a stream
4: Show stream settings
5: Finish</code></pre>
<p>If you choose to add a stream, you will be guided through major
decision points.</p>
</div>
<div class="section level2">
<h2 id="global-options">Global Options<a class="anchor" aria-label="anchor" href="#global-options"></a>
</h2>
<p>The first prompts define global postprocessing behavior. You specify
which fMRIPrep outputs to process (<code>input_regex</code>), the BIDS
description for final files (<code>bids_desc</code>), whether to keep
intermediate images, and if existing outputs should be overwritten. The
TR of your scans and an optional brain mask file are also collected.</p>
<div class="section level3">
<h3 id="selecting-bold-files-with-input_regex">Selecting BOLD files with <code>input_regex</code><a class="anchor" aria-label="anchor" href="#selecting-bold-files-with-input_regex"></a>
</h3>
<p>The <code>input_regex</code> setting controls which preprocessed
NIfTI files are entered into this postprocessing stream. Instead of
writing a full regular expression, you may supply BIDS entity-value
pairs that are converted to a regex at runtime. For example:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>desc<span class="sc">:</span>preproc task<span class="sc">:</span>ridl suffix<span class="sc">:</span>bold</span></code></pre></div>
<p>selects any file containing <code>task-ridl</code> and
<code>desc-preproc</code> with a <code>bold</code> suffix, producing
<code>".*task-ridl(_[^_]+)*_desc-preproc(_[^_]+)*_bold\\.nii(\\.gz)?$"</code>.</p>
<p>To provide a custom regular expression, prefix it with
<code>regex:</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>regex<span class="sc">:</span> .<span class="sc">*</span>task<span class="sc">-</span>rest.<span class="sc">*</span>preproc.<span class="sc">*</span>\.nii\.gz<span class="sc">$</span></span></code></pre></div>
<p>This pattern matches any file containing <code>task-rest</code> and
ending in <code>_desc-preproc_bold.nii.gz</code>. You could create
another configuration for task-based data using a different
expression.</p>
</div>
<div class="section level3">
<h3 id="output-naming-with-bids_desc">Output naming with <code>bids_desc</code><a class="anchor" aria-label="anchor" href="#output-naming-with-bids_desc"></a>
</h3>
<p>Every postprocessing stream is also defined by a <a href="https://bids-specification.readthedocs.io/en/stable/derivatives/common-data-types.html#preprocessed-or-cleaned-data" class="external-link">BIDS
description field</a>. This field (<code>bids_desc</code>) is used to
label of every postprocessed for the stream. For example, if the input
filename is</p>
<pre><code>sub-01_task-rest_run-1_space-MNI152NLin2009cAsym_desc-preproc_bold.nii.gz</code></pre>
<p>and you choose <code>bids_desc = "clean"</code>, the output will be
named</p>
<pre><code>sub-01_task-rest_run-1_space-MNI152NLin2009cAsym_desc-clean_bold.nii.gz</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="individual-processing-steps">Individual Processing Steps<a class="anchor" aria-label="anchor" href="#individual-processing-steps"></a>
</h2>
<p>After the global settings, the postprocessing menus walk through a
sequence of setup functions for each optional step. You may enable or
skip any of them. Below we summarize the purpose of each step, how to
enable it, and key options the setup functions will prompt for.</p>
<div class="section level3">
<h3 id="applying-a-brain-mask">Applying a Brain Mask<a class="anchor" aria-label="anchor" href="#applying-a-brain-mask"></a>
</h3>
<p><code><a href="../reference/setup_apply_mask.html">setup_apply_mask()</a></code> controls whether to apply a binary
brain mask to all BOLD runs. The prompt explains the rationale and lets
you provide a mask file and output prefix.</p>
<pre><code>Applying a brain mask to your fMRI data ensures that only in-brain voxels are retained during analysis.
This step is optional but often recommended for improving efficiency and accuracy in subsequent processing.
The mask will be applied as a binary filter to the 4D functional data, zeroing out signal outside the brain.
You can specify a custom mask file (in the same space and resolution as your fMRI data), or use the default
mask produced by your preprocessing pipeline.
Do you want to apply a brain mask to your fMRI data?</code></pre>
<p>Options include a path to the mask file (<code>mask_file</code>) and
a prefix for the masked output (<code>prefix</code>, default
<code>"m"</code>).【F:R/setup_postprocess.R†L496-L544】</p>
</div>
<div class="section level3">
<h3 id="spatial-smoothing">Spatial Smoothing<a class="anchor" aria-label="anchor" href="#spatial-smoothing"></a>
</h3>
<p>Spatial smoothing applies a 3D Gaussian kernel to the BOLD fMRI data,
which typically increases the signal-to-noise ratio and improves overlap
across subjects by reducing high-frequency spatial noise.</p>
<p>You will be asked to specify the size of the smoothing kernel in
millimeters (full width at half maximum, or FWHM). Common choices range
from 4mm to 8mm. Smoothing is achieved using FSL’s susan command, which
applies a nonlinear filtering algorithm that seeks to smooth together
only voxels of similar intensities. Technical details are <a href="https://users.fmrib.ox.ac.uk/~steve/susan/susan/node18.html#SECTION00062000000000000000" class="external-link">here</a></p>
<pre><code>-------------------------------------------------------------------------------------------
Spatial smoothing applies a 3D Gaussian kernel to the BOLD fMRI data, which increases 
the signal-to-noise ratio and improves overlap across subjects by reducing high-frequency
spatial noise.

You will be asked to specify the size of the smoothing kernel in millimeters
(full width at half maximum, or FWHM). Common choices range from 4mm to 8mm.

Do you want to apply spatial smoothing to the BOLD data as part of postprocessing?

Apply spatial smoothing? (yes/no) &gt; y
Spatial smoothing FWHM (mm) &gt; 5
</code></pre>
</div>
<div class="section level3">
<h3 id="icaaroma-denoising">ICA‑AROMA Denoising<a class="anchor" aria-label="anchor" href="#icaaroma-denoising"></a>
</h3>
<p>For ICA-AROMA denoising to be applied during postprocessing, you must
enable it in the project configuration and it must have been run at some
point (i.e., <code>Run ICA-AROMA?</code> in <code><a href="../reference/run_project.html">run_project()</a></code>).
This will produce a set of output files, including
<code>*_desc-MELODIC_mixing.tsv</code> (the mixing matrix), which
contains the spatiotemporal components identified both as noise and
signal by the algorithm.</p>
<p>When ICA‑AROMA outputs are available, you can regress out the noise
components as a postprocessing step. Building on the original papers
(Pruim et al., 2015), we recommend ‘nonaggressive’ removal, which only
removes the variance in ‘noise’ components that is not correlated with
signal components (i.e., partial effects in multiple regression). As
detailed below, if AROMA is applied to the fMRI data, the components
will also be regressed out of any confounds. Note that as of 8Aug2025,
only nonaggressive denoising is supported, regardless of how you respond
to the prompts.</p>
<pre><code>------------------------------------------------------------------------------------------------------------------------
ICA-AROMA identifies motion-related independent components from the fMRI data and outputs
noise regressors (e.g., *_desc-aroma_timeseries.tsv) that can be used to denoise the BOLD signal.
The pipeline asks you decide about whether to run the data through ICA-AROMA, which generates various
files, but does not make any changes to the fMRI data.

Here, you can denoise the data using ICA-AROMA, which step applies the noise regressors
to the data using voxelwise regression, either:
  - nonaggressively (recommended), which removes *unique* variance from noise components only, or
  - aggressively, which removes all variance associated with the noise components.

Do you want to apply ICA-AROMA denoising during postprocessing?

Apply AROMA denoising? (yes/no) &gt; y
Use nonaggressive denoising? (yes/no; Press enter to accept default: yes) &gt; y</code></pre>
</div>
<div class="section level3">
<h3 id="temporal-filtering">Temporal filtering<a class="anchor" aria-label="anchor" href="#temporal-filtering"></a>
</h3>
<p>Temporal filtering removes low- and/or high-frequency components from
the fMRI time series. A high-pass filter (e.g., 0.008 Hz) is commonly
used to remove slow scanner drift, while a low-pass filter can remove
physiological noise such as respiratory or cardiac fluctuations.
Temporal filtering is common in both task-based and resting-state fMRI
analyses. In task fMRI, we often apply a gentle high-pass filter
(e.g. .008 Hz) to remove low-frequency drift that can weaken GLM
analyses that assume a constant baseline. In resting-state analyses,
people often bandpass filter.</p>
<p>We support both fslmaths -bptf and a Butterworth temporal filter. The
former is more common for task-based fMRI and the latter with
resting-state fMRI. If filtering is enabled, you will be asked to choose
between these filtering methods.</p>
<p>Per FSL’s documentation, -bptf uses a local fit of a straight line
(Gaussian-weighted within the line to give a smooth response) to remove
low frequency artifacts. This is preferable to sharp rolloff FIR-based
filtering as it does not introduce autocorrelations into the data. These
‘ringing artifacts’ can induce negative autocorrelations, which
interfere with GLM software that correects for autocorrelation (e.g.,
Tukey tapering in FSL feat). Low-pass temporal filtering reduces high
frequency noise by Gaussian smoothing, but also reduces the strength of
the signal of interest, particularly for single-event experiments.</p>
<p>Butterworth filtering is a common temporal filtering technique used
in fMRI postprocessing to attenuate low-frequency drifts and/or
high-frequency noise while preserving the passband signal with minimal
distortion. Unlike sharp cutoff filters, the Butterworth filter has a
maximally flat frequency response in the passband, making it well-suited
for applications requiring smooth transitions. In fMRI, it is typically
applied as a band-pass or high-pass filter to remove slow scanner drifts
and physiological noise outside the frequency range of interest (e.g.,
0.01–0.1 Hz for resting-state analyses). To avoid phase distortion,
BrainGnomes applies the filter bidirectionally (i.e., using forward and
reverse passes). BrainGnomes also uses a second-order Butterworth
filter, which has a good balance between frequency precision and smooth
rolloff (higher orders give more precise frequency control at the edges,
but have bigger risks of artifacts).</p>
<p>One of the virtues of FSL’s Gaussian line smoothing approach is that
it has a very gradual rolloff. That said, the frequency response is
broad and not sharply defined, which can lead to partial attenuation of
signals near cutoff (e.g., if your upper cutoff is .10 Hz, you might
still see attenuation at .09 Hz). The Butterworth filter will have more
precise control over the frequencies retained in the data but may have a
slightly higher risk of messing up the autocorrelation structure (due to
ringing).</p>
<p>Here is the order of prompts with example responses. Note that if you
skip one of the cutoffs (press enter at the prompt), then that side of
the filter will not be applied. For example, if you only enter a
low-pass cutoff</p>
<p><code>Apply temporal filtering? &gt; yes</code>
<code>Low-pass cutoff (Hz) (Press enter to skip) &gt; 0.009</code>
<code>High-pass cutoff (Hz)  (Press enter to skip) &gt; 0.08</code>
<code>Filtering method (fslmaths/butterworth) &gt; butterworth</code></p>
</div>
<div class="section level3">
<h3 id="scrubbing-highmotion-volumes">Scrubbing High‑Motion Volumes<a class="anchor" aria-label="anchor" href="#scrubbing-highmotion-volumes"></a>
</h3>
<p>‘Scrubbing’ refers to a set of procedures for reducing the impact of
high-motion/high-artifact volumes on fMRI analysis. The most typical
approach is to flag volumes based on their framewise displacement, a
measure of overall head displacement in any direction/rotation, and to
remove those volumes from the time series. That said, scrubbing
encompasses a wider range of decisions, such as whether to interpolate
the bad timepoints and whether to generate spike regressors while
leaving the fMRI data intact (e.g., for subsequent use in task-based
analysis). Importantly, scrubbing has tricky interactions with other
postprocessing steps, especially confound regression and temporal
filtering.</p>
<p>Temporal filtering removes specific <em>frequencies</em> from the
data, so we cannot simply delete volumes from the time series and hope
to have the filtering work as intended. Moreover, if we apply the
temporal filter prior to scrubbing, we can induce ‘ringing artifacts’
where large signal changes due to head motion are propagated to adjacent
timepoints (Carp, 2012, NeuroImage). One effective way to handle this is
to interpolate over bad volumes (cubic spline is common), then apply the
temporal filter, and later scrub out the bad (now interpolated)
timepoints. This is how <a href="https://nilearn.github.io/stable/modules/generated/nilearn.signal.clean.html#nilearn.signal.clean" class="external-link">nilearn</a>
and <a href="https://xcp-d.readthedocs.io/en/latest/workflows.html" class="external-link">XCP-D</a>
approach the problem. BrainGnomes also allows for spline interpolation
as a precursor to temporal filtering.</p>
<p>Another scrubbing interaction occurs with confound regression. If we
plan to regress out confound signals from the fMRI, we want to maximize
the denoising for the volumes we ultimately wish to analyze, not the
volumes we plan to scrub out. Consequently, we could either a) run
confound regression after scrubbing or b) optimize the fit of the
regression model only for good timepoints. Aligned with XCP-D pipeline,
we adopt the latter strategy, fitting the confound model on good
timepoints. This allows for (potentially interpolated) high-motion
timepoints to be retained in the final fMRI timeseries. Typically, we
would remove/scrub these, but if your analysis requires intact
timeseries (e.g., for a frequency-based analysis), perhaps you’d like to
keep all timepoints.</p>
<div class="section level4">
<h4 id="defining-scrubbed-volumes">Defining scrubbed volumes<a class="anchor" aria-label="anchor" href="#defining-scrubbed-volumes"></a>
</h4>
<p>If you enable scrubbing, you will be asked to define what constitutes
a ‘scrubbed’ volume. This should be a single logical expression in R
syntax that can be evaluated against the confounds TSV file produced by
fmriprep. For example, if you wish to scrub any volume with more than
0.5mm framewise displacement, the expression would be:
<code>framewise_displacement &gt; 0.5</code>. You can have logical
operators in the expression, too, allowing something like
<code>framewise_displacement &gt; 0.5 | dvars &gt; 5</code>.</p>
<p><code>Scrubbing expression(s) &gt; framewise_displacement &gt; 0.9</code></p>
<p>In addition, your scrubbing expression can specify a range of volumes
to scrub using a format like: ‘-1:1; dvars &gt; 1.5’. The part before
the semicolon (-1:1) defines a temporal window around the bad timepoint.
For example, ‘-1:0’ scrubs the bad timepoint and the volume before it.
If omitted, only the bad timepoint (0) is scrubbed. The part after the
semicolon (‘dvars &gt; 1.5’) defines the thresholding condition.</p>
</div>
<div class="section level4">
<h4 id="adding-scrubbing-spike-regressors-to-postprocessed-confounds">Adding scrubbing spike regressors to postprocessed confounds<a class="anchor" aria-label="anchor" href="#adding-scrubbing-spike-regressors-to-postprocessed-confounds"></a>
</h4>
<p>Next, you will be asked whether you want to add any volumes
identified as ‘bad’ by the scrubbing expression to your postprocessed
confounds.tsv file. This is only relevant if you enabled to the
(preceding) confound calculate step. In this case, BrainGnomes will
create spike regressors (1 at the bad timepoint, 0 elsewhere) for each
volume flagged, adding them to the final confounds.tsv file. Note that
if you ‘apply’ scrubbing – that is, remove the scrubbed timepoints – the
spike regressors will <em>not</em> be added to the postprocessed
confounds since they would just be all 0 anyhow.</p>
<p>Adding these spike regressors to the confounds.tsv file is useful if
you plan to include them as nuisance regressors in a larger (typically
GLM) analysis, rather than deleting those volumes entirely during
scrubbing.</p>
<p><code>Add any spike regressors (bad volumes) to postprocessed confounds.tsv file?</code></p>
</div>
<div class="section level4">
<h4 id="interpolation-of-scrubbed-volumes">Interpolation of scrubbed volumes<a class="anchor" aria-label="anchor" href="#interpolation-of-scrubbed-volumes"></a>
</h4>
<p>As noted above, temporal filtering can be problematic when there are
large intensity changes, potentially causing ringing artifacts that
spread motion-related contamination into adjacent volumes. One effective
way to mitigate this risk is to interpolate the bad timepoints prior to
temporal filtering. BrainGnomes achieves this using cubic natural spline
interpolation. We recommend interpolation if you are substantially
filtering your data (e.g., .009 – .08 Hz) and have evidence of strong
intensity artifacts (e.g., on fMRIPrep’s carpet plots).</p>
<p><code>Interpolate scrubbed values?</code></p>
</div>
<div class="section level4">
<h4 id="removing-scrubbed-volumes">Removing scrubbed volumes<a class="anchor" aria-label="anchor" href="#removing-scrubbed-volumes"></a>
</h4>
<p>The term ‘scrubbing’ traditionally referred to removing bad
(high-motion, high-fluctuation) timepoints from the fMRI timeseries
prior to analysis, particularly of resting-state functional
connectivity. This remains one of its most common uses.</p>
<p>If you would like to remove bad timepoints (based on the scrubbing
expression), say ‘yes’ to this question:</p>
<p><code>Remove scrubbed timepoints?</code></p>
<p>This will delete the bad volumes as well as corresponding rows in
your postprocessed confounds file (if relevant).</p>
</div>
</div>
<div class="section level3">
<h3 id="intensity-normalisation">Intensity Normalisation<a class="anchor" aria-label="anchor" href="#intensity-normalisation"></a>
</h3>
<p><code><a href="../reference/setup_intensity_normalization.html">setup_intensity_normalization()</a></code> rescales each run so
that the global median intensity matches a user‑specified value (default
10,000). This helps make signal units comparable across subjects.</p>
</div>
<div class="section level3">
<h3 id="confound-calculation-and-regression">Confound Calculation and Regression<a class="anchor" aria-label="anchor" href="#confound-calculation-and-regression"></a>
</h3>
<p>Two steps handle confounds. <code><a href="../reference/setup_confound_calculate.html">setup_confound_calculate()</a></code>
creates a TSV file of nuisance regressors (motion parameters, CompCor
components, DVARS, global signal, etc.) that may be filtered to match
the BOLD data. Columns to include are selected with patterns that can
contain regular expressions or numeric ranges inside angle brackets. For
example <code>a_comp_cor_&lt;1-6&gt;</code> expands to
<code>a_comp_cor_1</code> through <code>a_comp_cor_6</code> and a
pattern like <code>^trans_</code> will match all six motion parameters.
This expansion is implemented in
<code>expand_confound_columns()</code>.【F:R/postprocess_functions.R†L996-L1036】</p>
<p>Standard motion-confound bundles can also be selected using shortcuts
such as <code>"6p"</code>, <code>"12p"</code>, <code>"24p"</code>, or
<code>"36p"</code> to request common sets of motion parameters and their
derivatives/squared terms.</p>
<p>These shorthand specifications expand to the following:</p>
<pre><code>6p  = { rot_x, rot_y, rot_z, trans_x, trans_y, trans_z }

12p = { rot_x, rot_x_derivative1, rot_y, rot_y_derivative1,
      rot_z, rot_z_derivative1, trans_x, trans_x_derivative1,
      trans_y, trans_y_derivative1, trans_z, trans_z_derivative1 }
      
24p = { rot_x, rot_x_derivative1, rot_x_derivative1_power2, rot_x_power2,
      rot_y, rot_y_derivative1, rot_y_derivative1_power2, rot_y_power2,
      rot_z, rot_z_derivative1, rot_z_derivative1_power2, rot_z_power2,
      trans_x, trans_x_derivative1, trans_x_derivative1_power2, trans_x_power2,
      trans_y, trans_y_derivative1, trans_y_derivative1_power2, trans_y_power2,
      trans_z, trans_z_derivative1, trans_z_derivative1_power2, trans_z_power2 }
      
36p = { csf, csf_derivative1, csf_derivative1_power2, csf_power2,
      global_signal, global_signal_derivative1, global_signal_derivative1_power2,
      global_signal_power2,
      rot_x, rot_x_derivative1, rot_x_derivative1_power2, rot_x_power2,
      rot_y, rot_y_derivative1, rot_y_derivative1_power2, rot_y_power2,
      rot_z, rot_z_derivative1, rot_z_derivative1_power2, rot_z_power2,
      trans_x, trans_x_derivative1, trans_x_derivative1_power2, trans_x_power2,
      trans_y, trans_y_derivative1, trans_y_derivative1_power2, trans_y_power2,
      trans_z, trans_z_derivative1, trans_z_derivative1_power2, trans_z_power2,
      white_matter, white_matter_derivative1, white_matter_derivative1_power2,
      white_matter_power2 }</code></pre>
<p>Filtered confounds (listed in <code>columns</code>) undergo the same
temporal filtering as the BOLD data, while unfiltered confounds (listed
in <code>noproc_columns</code>) are appended without processing. Typical
unfiltered regressors include binary spike regressors from
scrubbing.</p>
<p>Confound selection accepts regular expressions and numeric ranges.
For instance <code>^trans_</code> matches all six translational motion
parameters and <code>a_comp_cor_&lt;1-6&gt;</code> expands to the first
six CompCor components. Both filtered and unfiltered sets may use these
patterns, giving fine-grained control over nuisance regressors.</p>
<p><code><a href="../reference/setup_confound_regression.html">setup_confound_regression()</a></code> optionally performs
voxelwise regression of these confounds. If scrubbing is enabled, the
censor file written during <code><a href="../reference/setup_scrubbing.html">setup_scrubbing()</a></code> is passed to
the regression step so that model fits are computed using only volumes
marked as “good.”【F:R/postprocess_functions.R†L748-L764】 The residuals
are written to new NIfTI files with a chosen prefix. Because filtered
confounds match the exact temporal treatment of the BOLD data, this
regression step is safe from mismatch artifacts, similar to the strategy
described in the xcp-d documentation.</p>
</div>
<div class="section level3">
<h3 id="ordering-steps">Ordering Steps<a class="anchor" aria-label="anchor" href="#ordering-steps"></a>
</h3>
<p>Finally, <code>setup_postproc_steps()</code> determines the order in
which enabled steps run. By default the order is masking, smoothing,
AROMA, optional scrubbing/interpolation, temporal filtering, confound
regression, and intensity normalisation. You may override this order by
answering “yes” to the prompt shown in the code
below.【F:R/setup_postprocess.R†L321-L358】</p>
</div>
</div>
<div class="section level2">
<h2 id="running-postprocessing">Running Postprocessing<a class="anchor" aria-label="anchor" href="#running-postprocessing"></a>
</h2>
<p>After configuration, running <code><a href="../reference/run_project.html">run_project()</a></code> will execute
the selected postprocessing steps for each subject.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/run_project.html">run_project</a></span><span class="op">(</span><span class="va">scfg</span>, steps <span class="op">=</span> <span class="st">"postprocess"</span><span class="op">)</span></span></code></pre></div>
<p>The processing log for each subject is written to the project’s
<code>logs</code> folder, and the final postprocessed NIfTIs receive the
BIDS description specified earlier.</p>
</div>
<div class="section level2">
<h2 id="naming-and-use-of-intermediate-files">Naming and use of intermediate files<a class="anchor" aria-label="anchor" href="#naming-and-use-of-intermediate-files"></a>
</h2>
<p>During the setup of postprocessing, you will be asked whether to keep
intermediate files. Generally speaking, you should say ‘no’ since these
files only have a subset of postprocessing steps applied to them (e.g.,
smoothed, but not temporally filtered). That said, if you’d like to
inspect intermediate stages of processing, you acn</p>
</div>
<div class="section level2">
<h2 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<p>Postprocessing in BrainGnomes is fully configurable. Using
<code><a href="../reference/setup_project.html">setup_project()</a></code> or <code><a href="../reference/edit_project.html">edit_project()</a></code> you can
enable or disable each operation, control parameters such as smoothing
kernel and filtering cutoffs, and decide the order in which steps occur.
Running the project then applies these settings consistently across all
subjects.</p>
<p>For more details on individual functions see the package
documentation and the help pages referenced above.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Michael Hallquist.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
