% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/postprocess_functions.R
\name{butterworth_filter_4d}
\alias{butterworth_filter_4d}
\title{Apply a Butterworth Filter to a 4D NIfTI Image}
\usage{
butterworth_filter_4d(
  infile,
  tr,
  low_hz = NULL,
  high_hz = NULL,
  outfile = "",
  internal = FALSE,
  order = 2L,
  padtype = "even",
  use_zi = TRUE
)
}
\arguments{
\item{infile}{Character string. Path to the input 4D NIfTI file.}

\item{tr}{Numeric. The repetition time (TR) in seconds.}

\item{low_hz}{Numeric or NULL. Low cutoff frequency in Hz for high-pass or bandpass filtering.}

\item{high_hz}{Numeric or NULL. High cutoff frequency in Hz for low-pass or bandpass filtering.}

\item{outfile}{Character string. If provided, the filtered image is written to this file.}

\item{internal}{Logical. If FALSE (default), returns a \code{niftiImage} object with voxel values;
if TRUE, returns a minimal metadata internal object (see RNifti).}

\item{order}{Integer. Filter order (default = 4).}

\item{padtype}{Character string. Padding strategy: "even", "odd", "constant", or "zero". Default is "even".}

\item{use_zi}{Logical. Whether to use steady-state initial conditions (default = TRUE).}
}
\value{
A 4D NIfTI image, either written to \code{outfile} or returned as an object.
}
\description{
This function performs voxelwise temporal filtering of a 4D fMRI image using
a Butterworth IIR filter (low-pass, high-pass, or bandpass).
}
\details{
This function uses the \code{signal} package to compute IIR filter coefficients, and then
applies a zero-phase forward-backward filter to each voxel using C++ code via Rcpp.
}
\examples{
\dontrun{
butterworth_filter_4d("bold.nii.gz", tr = 2, low_hz = 0.01, high_hz = 0.1,
                       outfile = "bold_filtered.nii.gz")
}

}
