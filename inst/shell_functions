#!/bin/bash

# rel is shorthand for "run, echo, log". It looks for the environment $log_file and will write outputs there if specified.
# 
# Initial arguments specify what to do, including
# c: "comment"  -- print the command to the screen and log, but do not execute it
# t: "timeit"   -- print the command to screen and log, execute it, and include execution timing in output
# o: "output"   -- print the command to the log, but not screen, execute it, and print the command result to screen (can be captured by caller)
# -l <log>      -- specify the location of a log file used for logging. If not specified, rel will look at $log_file
#
# After parsing these arguments, all remaining arguments are assumed to be part of the command to be run. 
# rel uses printf-style quoting to preserve complex argument structure, including arguments with spaces,
# quotes, or shell metacharacters.
#
# Quoting Behavior:
#   - relq preserves spaces and special characters in arguments using shell-safe quoting.
#   - Each argument is quoted independently via `printf %q`, so complex argument structure is preserved.
#
# DO NOT pass unquoted variables that contain multiple words or special characters.
#    For example, this will NOT work as expected:
#       var="--arg='value with spaces'"
#       relq echo "Starting:" $var       # Will split into multiple arguments
#
# INSTEAD, quote the variable:
#       relq echo "Starting:" "$var"     # Preserves structure as a single argument
#
# Limitations:
#   - Cannot preserve nested quotes **within** arguments if they are broken during variable expansion.
#   - relq does not parse shell syntax; it only escapes each argument for safe shell execution.
#   - If you need true preservation of original quoting and spacing, pass arguments individually and quote variables.
# 
# Examples:
#   # Just write a comment to the log
#   rel c Hello this is my comment
#
#   # Time the execution of the sleep 10 command
#   rel t sleep 10
#
#   # Write to a particular log file
#   rel -l ~/my_log.txt sleep 10
function rel() {
  #function that runs, echos to terminal, and logs to file an arbitrary command
  local comment=0
  local timeit=0
  local capture_stdout=0
  local log=""          # log file where results should be written
  local tic=0
  local toc=0
  local cmdExit=0       # return value of this command    
  local cmdOutput=""    # stdout output of the command

  [ -n "$log_file" ] && log="$log_file"
  [[ $# -eq 0 ]] && echo "No arguments to rel provided" && return 1

  # Parse control flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      c) comment=1; shift ;;
      t) timeit=1; shift ;;
      o) capture_stdout=1; shift ;;
      -l) log="$2"; shift 2 ;;
      *) break ;;
    esac
  done

  # Quote each remaining argument safely
  local quoted_args=()
  for arg in "$@"; do
    quoted_args+=("$(printf "%q" "$arg")")
  done
  local cmd_str="${quoted_args[*]}"

  # Handle comment-only output
  if [[ $comment -eq 1 ]]; then
    # echo command to screen and log with dashes to offset text visually
    # if a blank string is passed as the command, include this without dashes (pure whitespace)
    [[ -n "$cmd_str" ]] && cmd_str="--- $cmd_str"
    echo -e "$cmd_str"
    # if we are writing comment to log, prepend with ## to separate comments from output
    [ -n "$log" ] && echo -e "## $cmd_str" >> "$log"
    return 0
  fi

  # log the command
  [ -n "$log" ] && echo -e "$cmd_str" >> "$log"

  # echo command to screen verbatim if we are not capturing stdout
  [ $capture_stdout -eq 0 ] && echo "$cmd_str"

  [ $timeit -eq 1 ] && tic=$(date +%s) # start timing
  
  #run command
  if [[ $capture_stdout -eq 1 ]]; then
    # if we are capturing stdout, we need to save the output of the command and not echo it to the screen
    cmdOutput=$(eval "$cmd_str")
    cmdExit=$?
    [ -n "$log" ] && echo -e "## stdout: $cmdOutput" >> "$log"
  else
    # otherwise, run the command and let its output print to the screen
    eval "$cmd_str"
    cmdExit=$?
  fi

  [ $timeit -eq 1 ] && toc=$(date +%s)

  # handle timing output
  if [[ $timeit -eq 1 && $capture_stdout -eq 0 ]]; then
    local msg="##  Command took $((toc - tic)) seconds"
    [ -n "$log" ] && echo -e "$msg" >> "$log" || echo -e "$msg"
  fi

  # Return captured output if requested
  [ $capture_stdout -eq 1 ] && echo "$cmdOutput"
  return $cmdExit  #exit status of command
}

run_bg_and_wait() {
  local pid="$1"
  local out_var="$2"
  local status=0
  local saved_err_trap=""
  local had_errexit=0
  local had_errtrace=0

  if [[ -z "$pid" ]]; then
    status=1
  else
    # Why this is needed:
    # `wait` returns the child exit status. For long-running tools (fMRIPrep/AROMA),
    # a non-zero status can occur even when logs indicate successful completion.
    # We intentionally defer failure classification to caller logic (e.g., success-token
    # checks), so `wait` must not trigger `trap ERR` or implicit errexit here.
    #
    # Save current trap/options, suppress ERR handling only for wait, then restore.
    saved_err_trap="$(trap -p ERR || true)"
    [[ $- == *e* ]] && had_errexit=1
    [[ $- == *E* ]] && had_errtrace=1

    trap - ERR
    set +eE
    wait "$pid"
    status=$?

    if [[ $had_errexit -eq 1 ]]; then set -e; else set +e; fi
    if [[ $had_errtrace -eq 1 ]]; then set -E; else set +E; fi

    if [[ -n "$saved_err_trap" ]]; then
      eval "$saved_err_trap"
    else
      trap - ERR
    fi
  fi

  if [[ -n "$out_var" ]]; then
    printf -v "$out_var" '%s' "$status"
  else
    echo "$status"
  fi
  return 0
}

mark_failed_in_tracking_db() {
  local step="${1:-unknown_step}"
  local reason="${2:-unspecified}"
  local job_id="${3:-}"
  local resolved_job_id="${job_id:-${SLURM_JOB_ID:-${PBS_JOBID:-}}}"
  local rscript_bin=""
  local saved_err_trap=""
  local had_errexit=0
  local had_errtrace=0
  local upd_status=0

  [[ -n "$R_HOME" ]] && rscript_bin="${R_HOME}/bin/Rscript"

  if [[ -z "$resolved_job_id" || -z "$upd_job_status_path" || -z "$sqlite_db" || -z "$rscript_bin" ]]; then
    log_message WARN "Skipping SQLite FAILED update for ${step} (${reason}): missing job metadata."
    return 0
  fi
  if [[ ! -x "$rscript_bin" ]]; then
    log_message WARN "Skipping SQLite FAILED update for ${step}: cannot execute ${rscript_bin}."
    return 0
  fi
  if [[ ! -f "$upd_job_status_path" ]]; then
    log_message WARN "Skipping SQLite FAILED update for ${step}: upd_job_status_path not found (${upd_job_status_path})."
    return 0
  fi

  # Prevent recursive trap handling if the status update command itself fails.
  saved_err_trap="$(trap -p ERR || true)"
  [[ $- == *e* ]] && had_errexit=1
  [[ $- == *E* ]] && had_errtrace=1
  trap - ERR
  set +eE

  "$rscript_bin" "$upd_job_status_path" --job_id "$resolved_job_id" --sqlite_db "$sqlite_db" --status "FAILED" --cascade
  upd_status=$?

  if [[ $had_errexit -eq 1 ]]; then set -e; else set +e; fi
  if [[ $had_errtrace -eq 1 ]]; then set -E; else set +E; fi
  if [[ -n "$saved_err_trap" ]]; then
    eval "$saved_err_trap"
  else
    trap - ERR
  fi

  if [[ $upd_status -ne 0 ]]; then
    log_message WARN "Failed to set SQLite status to FAILED for ${step} (job_id: ${resolved_job_id}, reason: ${reason})."
  else
    log_message INFO "Set SQLite status to FAILED for ${step} (job_id: ${resolved_job_id}, reason: ${reason})."
  fi
  return 0
}


function trap_job_failure() {
  local step="$1"
  local signal="$2"
  local now
  now=$(date +"%Y-%m-%d %H:%M:%S")
  local fail_file=".${step}_fail"
  [ -n "$complete_file" ] && fail_file="${complete_file%_complete}_fail"

  # "unknown" if SLURM variables are unset
  local resolved_job_id="${SLURM_JOB_ID:-${PBS_JOBID:-}}"
  local job_id="${resolved_job_id:-unknown}"
  local job_name="${SLURM_JOB_NAME:-unknown}"
  local err="${stderr_log:-unknown}"

  {
    echo "[$now] $step job failed."
    echo "  Signal     : $signal"
    echo "  Job ID     : $job_id"
    echo "  Job Name   : $job_name"
    echo "  Working Dir: $(pwd)"
    echo
  } >> "$fail_file"

  log_message ERROR $step job failed. Check $err.
  log_message ERROR "  Signal     : $signal"
  log_message ERROR "  Job ID     : $job_id"
  log_message ERROR "  Job Name   : $job_name"
  log_message ERROR "  Working Dir: $(pwd)"
  mark_failed_in_tracking_db "$step" "signal:${signal}" "$resolved_job_id"

  exit 1
}

function archive_file() {
    fname="$1"
    if [ -f "$fname" ]; then
    	#stat and date are not portable across Linux and BSD...
      [ $( uname ) = Darwin ] && mtime=$( stat -f "%Sm" -t "%Y%m%d_%H%M" "${fname}" ) || mtime=$( date -r "${fname}" +%Y%m%d_%H%M )
      mv "$fname" "${fname}_${mtime}"
    fi
    return 0
}

cleanup_fail_marker() {
    local complete_path="$1"
    [ -z "$complete_path" ] && return 0
    local fail_file="${complete_path%_complete}_fail"
    [ ! -f "$fail_file" ] && return 0

    local mtime
    if [ "$(uname)" = "Darwin" ]; then
      mtime=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$fail_file" 2>/dev/null)
    else
      mtime=$(date -r "$fail_file" +"%Y-%m-%d %H:%M:%S" 2>/dev/null)
    fi
    [ -z "$mtime" ] && mtime="unknown"

    rm -f "$fail_file"
    log_message INFO "Removed stale fail marker $fail_file (mtime: $mtime)."
}


#adapted from here: https://gist.github.com/aguy/2359833
# usage: trap 'traperror "<name>" $? $LINENO "${BASH_LINENO[0]}" "$BASH_COMMAND" "${FUNCNAME[*]:-::}"' ERR
function traperror () {
    local step="${1:-unknown_step}"
    local err=${2:-1} # error code -- default 1
    local line="${3:-N/A}" # LINENO -- default N/A
    local linecallfunc="${4:-N/A}"
    local command="${5:-unknown_command}"
    local funcstack="${6:-::}"
    local dotfile=".${step}_fail"
    [ -n "$complete_file" ] && dotfile="${complete_file%_complete}_fail" # prefer complete file

    archive_file "$dotfile" #move any existing crash file out of the way
    {
      echo "$(date) $(hostname) $0: ERROR '$command' failed at line $line; exited with status: $err"

      if [[ "$funcstack" != "::" ]]; then
        echo -n "$0: DEBUG Error in ${funcstack} "
        [[ "$linecallfunc" != "N/A" ]] && echo "called at line $linecallfunc"
      fi

      echo -en "\nCurrent working directory:\n  $PWD\n"
      [ -n "$pkg_dir" ] && echo "Location of BrainGnomes installation: $pkg_dir"

      if [ -r "$log_file" ]; then
        local cmd_tail
        cmd_tail=$(tail -n 10 "$log_file")
        printf "\n\nLast 10 lines of command log file:\n---------\n\n%s\n" "$cmd_tail"
      fi

      if [ -r "$stdout_log" ]; then
        local stdout_tail
        stdout_tail=$(tail -n 10 "$stdout_log")
        printf "\n\nLast 10 lines of stdout file:\n---------\n\n%s\n" "$stdout_tail"
      fi

      if [ -r "$stderr_log" ]; then
        local stderr_tail
        stderr_tail=$(tail -n 10 "$stderr_log")
        printf "\n\nLast 10 lines of stderr file:\n---------\n\n%s\n" "$stderr_tail"
      fi
    } >> "$dotfile"

    # send dotfile to stderr
    cat "$dotfile" >&2
    mark_failed_in_tracking_db "$step" "err_status:${err}" "${SLURM_JOB_ID:-${PBS_JOBID:-}}"

    exit "$err"  
}


log_level_rank() {
  local lvl=${1^^}
  case "$lvl" in
    TRACE) echo 600 ;;
    DEBUG) echo 500 ;;
    INFO) echo 400 ;;
    WARN|WARNING) echo 300 ;;
    ERROR) echo 200 ;;
    FATAL|CRITICAL) echo 100 ;;
    *) echo 400 ;;
  esac
}

function log_message() {
  [[ $# -eq 0 ]] && echo "No arguments to log_message provided" && return 1
  local level=${1^^}
  shift
  local message="$*"

  local threshold=${LOG_LEVEL:-${log_level:-INFO}}
  threshold=${threshold^^}
  local level_rank
  local threshold_rank
  level_rank=$(log_level_rank "$level")
  threshold_rank=$(log_level_rank "$threshold")
  if [[ $level_rank -gt $threshold_rank ]]; then
    return 0
  fi
  
  # Timestamp
  local timestamp
  timestamp=$(date +"%Y-%m-%d %H:%M:%S.%3N")

  # Final log line
  local log_line="$level  [$timestamp] $message"

  # Output to screen and/or log file
  echo "$log_line"
  if [[ -n "$log_file" ]]; then
    echo "$log_line" >> "$log_file"
  fi
}

function warn() {
  echo -e "$@" >&2
}

function abspath() {
  [ -z "$1" ] && return 1
  local dir
  dir="$(dirname "$1")"

  if [ ! -d "$dir" ]; then
    warn "WARNING: $FUNCNAME: cannot find dir for '$1' (while in '$(pwd)')"
    echo "$1"
    return 1
  fi

  echo "$(cd "$dir" && pwd)/$(basename "$1")"
}

get_slurm_cpus() {
  if [[ -n "$SLURM_JOB_CPUS_PER_NODE" ]]; then
    echo "$SLURM_JOB_CPUS_PER_NODE"
    return 0
  fi

  if [[ -n "$SLURM_JOB_ID" ]]; then
    scontrol show job "$SLURM_JOB_ID" | awk ' { for (i = 1; i <= NF; i++) { split($i, kv, "="); if (kv[1] == "NumCPUs") { print kv[2]; exit } } }'
    return 0
  fi

  echo "0"
  return 1
}

get_slurm_memory_gb() {
  local mem_mb=""

  if [[ -n "$SLURM_MEM_PER_NODE" ]]; then
    mem_mb="$SLURM_MEM_PER_NODE"
  elif [[ -n "$SLURM_MEM_PER_CPU" && -n "$SLURM_JOB_CPUS_PER_NODE" ]]; then
    mem_mb=$(( SLURM_MEM_PER_CPU * SLURM_JOB_CPUS_PER_NODE ))
  elif [[ -n "$SLURM_JOB_ID" ]]; then
    mem_raw=$(scontrol show job "$SLURM_JOB_ID" | awk -F= '/ReqMem/ {print $2}' | awk '{print $1}')
    mem_val="${mem_raw%?}"
    mem_unit="${mem_raw: -1}"
    case "$mem_unit" in
      M|m) mem_mb="$mem_val" ;;
      G|g) mem_mb=$(( mem_val * 1024 )) ;;
      T|t) mem_mb=$(( mem_val * 1024 * 1024 )) ;;
      *) mem_mb="" ;;
    esac
  fi

  if [[ -n "$mem_mb" ]]; then
    awk "BEGIN {printf \"%.2f\", $mem_mb/1024}"
    return 0
  else
    echo "0.00"
    return 1
  fi
}

function time_elapsed() {
  # requires $start_time to be present
  if [ -z "$start_time" ]; then
    echo "unknown"
    return 1
  fi

  local end_time=$(date +%s)
  local elapsed=$((end_time - start_time))
  local hours=$((elapsed / 3600))
  local minutes=$(((elapsed % 3600) / 60))
  local seconds=$((elapsed % 60))
  
  echo "${hours}h ${minutes}m ${seconds}s"
  return 0
}

# remove extension from any given file, including possible compression extensions
remove_ext() {
  local filename="$1"
  local base="${filename##*/}"  # remove directory path
  base="${base%.gz}"
  base="${base%.bz2}"
  base="${base%.xz}"
  base="${base%.zip}"
  base="${base%.*}"             # remove primary extension (e.g., .nii, .txt, .csv)
  echo "$base"
}

# rm_cli_fields - Remove specific CLI arguments from a command-line string
#
# This function strips out command-line arguments matching a given list of option names.
# It handles flags in the form:
#   --flag=value
#   --flag value
#   --flag            (boolean-style)
#
# It ensures partial matches (e.g., removing "input" doesn't strip "input_regex") are avoided.
#
# Parameters:
#   $1 - The original CLI string
#   $@ - A list of argument names (without the "--" prefix) to remove
#
# Returns:
#   Prints the modified CLI string to stdout with specified arguments removed
#
# Example:
#   cli="--input=2 --test --aroma /path --input_regex=_desc"
#   clean_cli=$(rm_cli_fields "$cli" input aroma)
#   echo "$clean_cli"
#   # Output: --test --input_regex=_desc
rm_cli_fields() {
  local input_str="$1"
  shift
  local -a remove_fields=("$@")

  echo "$input_str" | awk -v fields="${remove_fields[*]}" '
    BEGIN {
      # Build a map of field names to remove
      n = split(fields, f, " ")
      for (i = 1; i <= n; i++) {
        rm["--" f[i]] = 1
      }
    }
    {
      i = 1
      while (i <= NF) {
        key = $i
        val = $(i+1)

        # Check if --flag=value form
        split(key, kv, "=")
        k = kv[1]

        if (rm[key] || rm[k]) {
          # skip --flag or --flag=value or --flag value
          if (key ~ /=/) {
            i += 1
          } else if (val !~ /^--/) {
            i += 2
          } else {
            i += 1
          }
        } else {
          printf "%s ", key
          i += 1
        }
      }
      print ""
    }
  '
}
